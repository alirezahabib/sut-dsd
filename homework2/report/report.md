# تمرین ۲ طراحی سیستم‌های دیجیتال
> Alireza Habibzadeh `99109393`

## 4
### A
```verilog
always @(posedge clock)
if(reset)
out <= 0;
else
out <= in;
```

در این مدار reset **ناهم‌زمان** است. چرا که بلاک `always` تنها با هر لبه‌ی بالارونده‌ی کلاک اجرا می‌شود.

در هر لبه‌ی بالارونده‌ی کلاک مقدار `in` در `out` ظاهر می‌شود و مستقل از تغییر `in` بین دو کلاک، این مقدار در `out` تا کلاک بعدی حفظ می‌شود. پس می‌توان گفت این قطعه یک D-flipflop است که ورودی `in` به `D` وصل شده.
ورودی‌های `clock` و `reset` هم به پایه‌های متناظرشان وصل هستند.
فلیپ‌فلاپ استفاده شده هم از نوع
Active High
است و مقدار اولیه‌ی خروجی پس از ریست `0` می‌باشد.
### B
```verilog
always @(posedge clock)
if(reset)
out <= 0;
else if(!clear)
out <= in;
```

در این مدار نیز به همان دلیل قبلی reset **ناهم‌زمان** است.

مدار اینجا نیز همان D-flipflop قبلی است با این تفاوت که فلیپ‌فلاپ ما دارای پایه‌ی `clear` نیز هست. این پایه از نوع Active Low است یعنی وقتی ‍`clear = 1` باشد هیچ اتفاقی نمی‌افتد و وقتی `clear = 0` باشد مقدار قبلی فلیپ‌فلاپ clear شده و مقدار جدید از ‍`in` خوانده می‌شود.
(ریست فلیپ‌فلاپی که اینجا قرار دارد از نوع ناهم‌زمان است.)

### C
```verilog
always @(posedge clock)
if(sel)
out <= in0;
else
out <= in1;
```

![circuit-C](circuitC.svg)

یک مالتی‌پلکسر داریم که `sel` بین `in1` و `in0` (با همین ترتیب یعنی ‍`out(sel = 0) = in1`) انتخاب می‌کند. سپس خروجی تا کلاک بعدی latch می‌شود. 

### D
```verilog
always @(posedge clock)
if(!clear)
out <= in;
```

![circuit-D](circuitD.svg)

مشابه B است فقط ‍`reset` نداریم. تنها اگر `clear = 0` باشد خروجی تازه شده و از روی ‍`in` خوانده می‌شود.

### E
```verilog
always @(posedge clock or
posedge
reset)
if(reset)
out <= 0;
else
out <= in;
```

در این مدار reset **هم‌زمان** است. چرا که با لبه‌ی بالارونده‌ی reset نیز بلاک `always` اجرا شده و کاری که برای reset تعریف کردیم را انجام می‌دهد.

ماننده بخش A یک D-flipflop است. اما اینجا ریست به صورت هم‌زمان طراحی شده. پایه‌ی ‍`in` به ‍`D` و `out` به `Q` فلیپ‌فلاپ وصل شده و ‍‍`reset` و `clock` به پایه‌های متناظرشان.

